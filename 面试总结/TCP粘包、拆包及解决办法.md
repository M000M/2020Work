### TCP粘包、拆包及解决办法

[TOC]

#### 1. TCP会发生粘包、拆包，UDP会发生粘包、拆包吗？

TCP、UDP是传输层的协议，TCP会发生粘包，UDP会发生粘包吗？

UDP不会发生粘包现象。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来只是UDP数据报文的长度，因此在应用层能够很好地将不同的数据报文区分开，从而避免粘包和拆包的问题。

TCP是基于字节流的瑞然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或则拆包现象发生的可能。

**TCP报文头格式**

![image-20200806150343160](/Users/didi/Library/Application Support/typora-user-images/image-20200806150343160.png)

**UDP报文头格式**

![image-20200806150447451](/Users/didi/Library/Application Support/typora-user-images/image-20200806150447451.png)



#### 2. 什么是粘包、拆包？为什么会发生TCP粘包、拆包？

假设客户端要向服务端发送两个数据包，那么服务端收到的数据包分为如下三种情况

1. 正常情况

<img src="/Users/didi/Library/Application Support/typora-user-images/image-20200806144154499.png" alt="image-20200806144154499" style="zoom:50%;" />

2. 只接收到一个数据包。这一个数据包中包含了发送端发送的连个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

    <img src="/Users/didi/Library/Application Support/typora-user-images/image-20200806144455639.png" alt="image-20200806144455639" style="zoom:50%;" />

3. 接收到两个数据包，但是连个数据包要么不完整，要么多了一块。这种情况就是发生了粘包和拆包。这种情况若不处理，对于接收端来说同样是不嗨哦处理的。

<img src="/Users/didi/Library/Application Support/typora-user-images/image-20200806144045910.png" alt="image-20200806144045910" style="zoom:50%;" />

**拆包**

1. 应用程序写入的数据大于TCP发送缓冲区剩余缓空间大小，这将会发生拆包；
2. 待发送的数据大于MSS（最大报文长度），当TCP报文长度-TCP头部长度>MSS的时候将发生拆包

**粘包**

1. 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
2. 接受数据段的应用层没有及时读取接受缓存区中的数据，将发生粘包。

#### 3. 粘包、拆包解决办法

通过以上分析清楚了粘包和拆包产生的原因，如何解决这些问题？解决问题的关键在于如何给没饿过数据包添加边界信息，常用的方法有如下几个？

1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了；
2. 发送端将每个数据包缝状为固定长度（不够的可以通过补0填充），这样接收端每次从接受缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来；
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

等等

参考：https://blog.csdn.net/wxy941011/article/details/80428470